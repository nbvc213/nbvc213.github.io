---
title: "密码学笔记"
layout: post
date: 2024-08-10 08:00:00 +0800
categories: 笔记
math: true
mermaid: true
---

## 密码学常见的困难问题



## 伪随机

### 伪随机生成器（Pseudorandom Generator）

伪随机生成器是一种高效、确定性的算法，它可以把短而随机的输入（称为种子 seed）转换为较长的“看起来随机”（即伪随机）的输出。换句话来说，伪随机生成器用少量的真随机字符串来生成大量的伪随机字符串。

> [!note]
>
> 如果一个字符串是伪随机的，那么它与相同长度的真随机的字符串无法区分。

伪随机生成器的**正式定义**如下：

令 $G$ 为一个确定性的多项式时间算法，使得对于任意 $n$ 和任意输入 $s \in \{0,1\}^n$，结果 $G(s)$ 是一个长度为 $\ell(n)$ 的字符串。若以下条件成立，则 $G$ 是一个**伪随机生成器**：

1. **扩展性**：对于每个 $n$，都有 $\ell(n) > n$。
2. **伪随机性**：对于任意概率多项式时间算法 $D$，存在一个可忽略的函数 $\text{negl}$，使得
   $$
   \Big|\Pr[D(G(s))=1]-\Pr[D(r)=1]\Big|\leq\text{negl}(n)
   $$
   其中，第一个概率是对于 $s \in \{0,1\}^n$ 的均匀选择和 $D$ 的随机性而言，第二个概率是对于 $r \in \{0,1\}^{\ell(n)}$ 的均匀选择和 $D$ 的随机性而言。

我们称 $\ell(n)$ 为 $G$ 的扩展因子。

### 伪随机函数（Pseudo-Random Function，PRF）

在伪随机生成器中，我们考虑的是“看起来随机（random-looking）”的字符串。而在伪随机函数中，我们考虑“看起来随机”的函数。

我们考虑有密钥的函数 $F : \{0, 1\}^n \times \{0, 1\}^n \to \{0, 1\}^n$，其中第一个输入称为**密钥**，并用 $k$ 指代，那么该函数 $y=F(k,x)$ 可以简写为 $y=F_k(x)$。设 $Func_n$ 为所有 $\{0, 1\}^n \to \{0, 1\}^n$ 函数的集合。如果 $F_k(x)$ 是伪随机函数（$k$ 是随机密钥），则 $F_k(x)$ 与 $Func_n$ 中任选的一个函数无法区分。

> [!note]
>
> 有密钥的函数 $F : \{0, 1\}^n \times \{0, 1\}^n \to \{0, 1\}^n$ 里的密钥 $k$ 可以理解为用来控制 $x\to y$ 的映射的一个参数，$y=F_k(x)$ 的定义域仍然只是 $x$ 的范围。如果不考虑 $k$，只考虑 $y=F(x)$ 这样“固定”的函数的伪随机性是没有意义的。
>
> 举例：假设有密钥的函数为 $F : \{0,1\} \times \{1,2,3\} \to \{1,2,3\}$，例如：$1\to1,2\to2,3\to3(k=0)$ 是一个函数，$1\to1,2\to3,3\to2(k=1)$ 又是一个函数。而 $Func$ 集合包括了所有 $\{1,2,3\} \to \{1,2,3\}$ 的函数，即共有 6 个函数（$3\times2\times1=6$）。真随机的函数是在 $Func$ 集合（共 6 个函数）里随机选择的一个函数 $f(x)$。而 $F_k(x)$ 的 $k$ 的取值范围只有 $0,1$，任选一个 $k$ 得到的 $F_k(x)$ 也只是在两个函数中随机选择一个而已，我们认为如果 $F_k(x)$ 与 $f(x)$ 不可区分，则这个函数是伪随机的。

伪随机函数的**正式定义**如下：

一个高效的、长度保持的、有密钥的函数 $F : \{0, 1\}^* \times \{0, 1\}^* \to \{0, 1\}^*$ 是一个伪随机函数，如果对于所有概率多项式时间判别器 $D$，存在一个可忽略的函数 $\text{negl}$，使得
$$
\left| \Pr[D^{F_k(\cdot)}(1^n) = 1] - \Pr[D^{f(\cdot)}(1^n) = 1] \right| \leq \text{negl}(n)
$$
其中，第一个概率取决于 $k \in \{0, 1\}^n$ 的均匀选择和 $D$ 的随机性，第二个概率取决于 $f \in \text{Func}_n$ 的均匀选择和 $D$ 的随机性。

### 不经意伪随机函数（Oblivious Pseudorandom Function，OPRF）

不经意伪随机函数是一个两方参与的协议，一方为客户端，另一方为服务器。OPRF 其本质上仍然是一个伪随机函数 $F_k(x)$，其密钥 $k$ 由服务器提供，输入 $x$ 由客户端提供，最终输出结果 $y$ 返回给客户端。在这个过程中，服务器不知道 $x,y$，客户端不知道 $k$。

#### 基于 RSA 盲签名的 OPRF

**密钥生成**：服务器生成一对公私钥对 $(d,e)$ 和大素数 $p$，$d$ 为秘密指数，$e$ 为公开指数。满足 $d=e^{-1}\mod p$。

**盲化**：客户端选择一个随机的盲化因子 $r$，并计算盲化后的输入 $x'=x\cdot r^e$。

**输出**：服务器得到 $x'$ 后，计算 $y'=(x')^d$。此时 $y'$ 可以化简为
$$
y'=(x')^d=(x\cdot r^e)^d=x^d\cdot r
$$
**解盲**：客户端计算 $y=y'/r$ 即得到了 $x^d$。

#### 基于 DH 的 OPRF



## ECDSA 签名（Elliptic Curve Digital Signature Algorithm）

假设私钥为 $sk=a$，公钥为 $pk=aG$（$G$ 为椭圆曲线的生成元）。

签名者选择随机值 $k$ 作为临时密钥，计算 $R=kG$，取 $R$ 的 $x$ 轴坐标，记为 $r$。

签名者计算
$$
s=k^{-1}\cdot(H(m)+sk\cdot r)
$$
$(r,s)$ 即为最终的 ECDSA 签名。

验证者计算
$$
X=(x,y)=H(m)s^{-1}\cdot G+rs^{-1}\cdot pk
$$
判断下面等式是否成立，如果成立，则验证通过。（$p$ 为椭圆曲线的阶）
$$
x\equiv r\mod p
$$

> [!warning]
>
> 随机值 $k$ 是一次性的，不能使用重复的随机数。

## Schnorr 签名

Schnorr 由德国数学家和密码学家 Claus-Peter Schnorr 在 1990 年提出。

### 签名方案

假设私钥为 $sk=a$，公钥为 $pk=aG$（$G$ 为椭圆曲线的生成元），则消息 $m$ 的 Schnorr 签名 $(R,s)$ 计算方式如下：

签名者选择随机值 $k$ 作为临时密钥，计算
$$
\left\{\begin{array}{l}
R=kG\\
s=k+H(R,m)\cdot sk
\end{array}\right.
$$
$(R,s)$ 即为 $m$ 的 Schnorr 签名。

任何知晓 $pk$ 的人都可以验证消息 $m$ 的 Schnorr 签名 $(R,s)$，只需检查下面的等式是否成立即可：
$$
sG\stackrel{?}{=}R+H(R,m)\cdot pk
$$

> [!warning]
>
> 随机值 $k$ 是一次性的，不能使用重复的随机数，否则会泄露私钥 $sk$。

### 签名聚合

由于 Schnorr 签名是**线性**的，因此可以实现签名聚合，这在区块链场景下可以应用，使用签名聚合可以减少验证者的工作量。

但是前一节介绍的 Schnorr 签名方案不能用来实现签名聚合，这里需要使用 Schnorr 签名方案的一个**修改版本**，具体方案通过举例的方式介绍：

**Schnorr 签名方案的修改版本**：假设有 2 个用户（持有的公钥为 $pk_1,pk_2$）要对同一消息 $m$ 签名，那么：

1. 这两个用户先各自选择 $k_1,k_2$ 作为临时密钥，并各自计算 $R_1=k_1G,R_2=k_2G$。
2. 这两个用户将 $R_1,R_2$ 聚合，即 $R=R_1+R_2$。
3. 这两个用户**使用聚合后的 $R$ 来计算** $s_1,s_2$。

那么最终计算出的 2 个 Schnorr 签名为 $(R_1,s_1),(R_2,s_2)$。我们可以把公钥直接相加 $pk=pk_1+pk_2$，签名也直接相加 $(R,s)=(R_1+R_2,s_1+s_2)$。$(R,s)$ 即为**聚合签名**。

聚合签名的验证等式仍然满足
$$
sG=R+H(R,m)\cdot pk
$$
这是因为
$$
\begin{aligned}
sG &= R+H(R,m)\cdot pk\\
(s_1+s_2)G &= R_1+R_2+H(R,m)\cdot (pk_1+pk_2)\\
s_1G+s_2G &= R_1+H(R,m)\cdot pk_1 + R_2+H(R,m)\cdot pk_2
\end{aligned}
$$
这样，原本验证 2 个签名的任务就简化为验证 1 个签名（即聚合签名），而 $pk=pk_1+pk_2$ 被称为**聚合公钥**。

### 零知识证明

Schnorr 签名方案可以用来实现零知识证明，这是基于离散对数困难问题的。

#### 交互式 Schnorr

假设 Alice 想向 Bob 证明她知道 $sk=a$，并且 Bob 已知 $pk=aG$，那么：

1. Alice 随机选择一个临时密钥 $k$，计算 $R=kG$。
2. Bob 向 Alice 发送挑战 $c$。
3. Alice 使用挑战 $c$ 计算 $s=k+c\cdot sk$，并把 $s$ 发送给 Bob。
4. Bob 通过验证 $sG\stackrel{?}{=}R+c\cdot pk$ 是否成立来判断 Alice 是否真的知道 $sk=a$。

显然 Bob 在不知道 $sk$ 的条件下，是可以相信 Alice 是真的知道 $sk=a$。

> [!note]
>
> 1. 正如 Schnorr 签名方案一样，临时密钥 $k$ 每次都必须更换，否则会导致 $sk$ 的泄露。
> 2. 挑战 $c$ 必须由 Bob 选择，目的是防止 Alice 作假。这是因为在验证等式 $sG=R+c\cdot pk$ 中，如果 $c,k$ 都是 Alice 选择的话，那么 Alice 完全可以根据验证等式计算出 $s=(R+c\cdot pk)G^{-1}$，即使 Alice 并不知道 $sk$。

#### 非交互式 Schnorr

假设 Alice 想向 Bob 证明她知道 $sk=a$，并且 Bob 已知 $pk=aG$，那么：

1. Alice 随机选择一个临时密钥 $k$，计算
   $$
   \left\{\begin{array}{l}
   R=kG\\
   c=H(R,pk)\\
   s=k+c\cdot sk
   \end{array}\right.
   $$

2. Bob 首先验证 $c=H(R,pk)$ 是否正确计算，再验证 $sG\stackrel{?}{=}R+c\cdot pk$。

相比交互式 Schnorr，非交互式 Schnorr 选择了一个大家可以公开计算的值作为 $c$（同时它是哈希函数的输出，具有随机性），这样 Alice 就无法造假。

> [!note]
>
> ##### Fiat-Shamir 变换
>
> 从交互式 Schnorr 到非交互式 Schnorr，最大的区别是**使用了哈希函数的输出作为挑战 $c$**，而哈希函数的输入采用了 $R$ 和 $pk$，这是目前所有可公开的值。这样的变换可以解除对挑战者的需要，它被称为 **Fiat-Shamir 变换**。

## BLS 签名

该算法由斯坦福大学的 Dan Boneh、Ben Lynn 和 Hovav Shacham 一同提出的，以其名字的首字母缩写 BLS 来命名。

### 曲线哈希（Hashing to the curve）

一般的哈希函数是把输入的消息映射到定长字符串。而**曲线哈希**是把输入的消息映射到椭圆曲线上的一个点 $(x,y)$。一个简单的做法是：输入消息为 $m$，经过哈希计算 $H(m) = x$，再把 $x$ 代入椭圆曲线方程 $y^2=x^3+ax+b$ 计算得到两个点 $(x,y)$ 和 $(x,-y)$，选择其中一个点作为输出即可。

> 需要注意，把 $x$ 代入椭圆曲线方程 $y^2=x^3+ax+b$ 不一定能计算出对应的 $y$，因此可以把输入消息修改为 $m\parallel 1$，如果无法计算出对应的 $y$，则继续计算 $m\parallel 2$，直到能计算出 $y$ 为止。
{: .prompt-warning }

### 曲线配对

为了验证签名，我们需要使用双线性配对。双线性配对是一种特殊的函数，可以把椭圆曲线上两个点 $P,Q$ 映射到一个数。双线性配对有以下特性：**（这里的加和乘是什么运算？）**

[V神讲解椭圆曲线配对(上) - 简书 (jianshu.com)](https://www.jianshu.com/p/6630ed00f352)
$$
\hat{e}(aP,bQ)=\hat{e}(P,Q)^{ab}\\
\hat{e}(P,Q_1+Q_2)=\hat{e}(P,Q_1)\cdot\hat{e}(P,Q_2)\\
$$

> [!WARNING]
>
> 由于双线性配对算法并不高效，这也是 BLS 签名的一个缺点。

### BLS 签名方案

**计算签名**：假设私钥为 $sk=a$，公钥为 $pk=aG$（$G$ 为曲线的生成元），输入消息为 $m$，使用曲线哈希函数 $H:\{0,1\}^*\to\mathbb{G}$ 计算 $H(m)$，使用私钥计算的 BLS 签名为 $sig =a\cdot H(m)$。

**验证签名**：使用公钥和曲线配对来验证签名 $sig$：
$$
\begin{aligned}
\hat{e}(pk,H(m))& = \hat{e}(aG, H(m)) \\
&= \hat{e}(G, aH(m)) \\
&= \hat{e}(G, sig)
\end{aligned}
$$

### 签名聚合

假设有 3 个 BLS 签名 $sig_1,sig_2,sig_3$（分别对消息 $m_1,m_2,m_3$ 签名，使用的公钥分别是 $pk_1,pk_2,pk_3$），那么可以通过相加的方式把这 3 个签名聚合为一个签名：

$$
sig = sig_1+sig_2+sig_3
$$

验证方式如下：

$$
\begin{aligned}
\hat{e}(G,sig)&= \hat{e}(G,sig_1+sig_2+sig_3)\\
&= \hat{e}(G,sig_1)\cdot\hat{e}(G,sig_2)\cdot\hat{e}(G,sig_3)\\
&= \hat{e}(pk_1,H(m_1))\cdot\hat{e}(pk_2,H(m_2))\cdot\hat{e}(pk_3,H(m_3))
\end{aligned}
$$

使用签名聚合的优势在于可以把多个签名聚合为一个签名，这样减少了签名的存储空间。

### 多重签名（Multi-signature）

**M-of-N 多重签名**是指：总共有 N 个私钥，至少持有 M 个私钥做出的签名才是有效的。

M-of-N 多重签名主要用于区块链的加密货币场景，以 2-3 多重签名为例，……**（介绍多重签名的原理）**

使用 M-of-N 多重签名可以提高钱包的安全性，消除了单点故障（某一台计算机出现故障不会影响钱包的使用），相比 N-of-N 多重签名而言，它允许私钥的部分泄露（一个私钥的泄露不会影响钱包的使用）。

## 单点登录（Single Sign-on，SSO）

单点登录（SSO）是一种身份认证解决方案，可让用户通过一次性用户身份认证来登录多个应用程序和网站。例如，你可以用谷歌账号登录 Facebook。SSO 最直接的优点便是减少了用户记忆口令的负担，缺点是存在单点故障。

### 工作原理

SSO 服务由**身份认证服务提供商（IdP）**提供，IdP会为注册的用户颁发 **SSO 令牌**。用户可以使用 SSO 令牌去登录多个应用程序或网站。应用程序或网站在收到 SSO 令牌后会向 IdP 验证令牌。如果验证通过，则完成了应用程序或网站对用户的身份认证。

具体流程如下：

1. 用户首次访问一个需要身份认证的应用程序或系统。
2. 应用程序或系统将用户重定向到 IdP，用户在 IdP 上进行身份验证，通常是输入用户名和密码。
3. IdP 向用户颁发 SSO 令牌，该令牌包含有关用户身份认证的信息。
4. 用户被重定向回原始的应用程序或系统，并将 SSO 令牌传递给该应用程序或系统，应用程序或系统使用令牌向 IdP 验证用户身份，验证通过则授予用户访问权限。
5. 如果用户访问其他需要身份验证的应用程序或系统，该应用程序或系统将使用相同的令牌到 IdP 进行用户身份验证。

### SSO 实现

以下协议都实现了 SSO：

1. 安全断言标记语言（Security Assertion Markup Language，SAML）：基于 XML，仅支持基于 Web 的应用程序。
2. OpenID 连接（OpenID Connect，OIDC）：基于 OAuth 2.0 框架。

